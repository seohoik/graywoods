// 파일 경로 예시: src/pages/rss.xml.js 또는 src/pages/rss.xml.ts
// (Example file path: src/pages/rss.xml.js or src/pages/rss.xml.ts)

import rss from "@astrojs/rss";
import { getCollection } from "astro:content";
import { marked } from 'marked'; // Markdown을 HTML로 변환하기 위해

export async function GET(context) {
  const posts = await getCollection("posts");

  const items = await Promise.all(
    posts.map(async (post) => {
      let dateObject;
      const pubDateValue = post.data.pubDate;

      // --- a. pubDate 유효성 검사 및 Date 객체 확보 (Validate pubDate and get Date object) ---
      if (pubDateValue instanceof Date && !isNaN(pubDateValue.getTime())) {
        dateObject = pubDateValue;
      } else if (typeof pubDateValue === 'string') {
        dateObject = new Date(pubDateValue);
        if (isNaN(dateObject.getTime())) {
          console.warn(`[RSS Feed] Post ID "${post.id}" (title: "${post.data.title}"): Invalid date string for pubDate: "${pubDateValue}". Skipping this post.`);
          return null; // 유효하지 않은 날짜면 이 포스트는 RSS에서 제외 (Skip this post in RSS if date is invalid)
        }
      } else {
        console.warn(`[RSS Feed] Post ID "${post.id}" (title: "${post.data.title}"): pubDate is not a valid Date object or string. Received: ${JSON.stringify(pubDateValue)}. Skipping this post.`);
        return null; // 유효하지 않은 날짜 형식이면 제외 (Skip if invalid date format)
      }

      // --- b. 포스트의 실제 슬러그 확인 (Verify the post's actual slug) ---
      // post.slug는 Astro가 콘텐츠 컬렉션에서 자동으로 생성하는 파일명 기반 슬러그입니다.
      // post.slug is the filename-based slug automatically generated by Astro for content collections.
      if (!post.slug || typeof post.slug !== 'string' || post.slug.trim() === '') {
        console.warn(`[RSS Feed] Post ID "${post.id}" (title: "${post.data.title}"): Invalid or missing slug. Received: "${post.slug}". Skipping this post.`);
        return null; // 슬러그가 유효하지 않으면 제외
      }

      // --- c. 설명 자동 생성 수정 (Modified auto-create description) ---
      let description = post.data.description?.trim() ?? ""; // frontmatter의 description을 우선 사용

      // frontmatter에 description이 없고, 포스트 본문(post.body)이 있는 경우에만 자동 생성 시도
      if (!description && post.body) {
        try {
          const htmlContent = marked.parse(post.body); // Markdown을 HTML로 변환
          let plainText = String(htmlContent)
            .replace(/<[^>]+>/g, " ")      // HTML 태그 제거 (Strip HTML tags)
            .replace(/\n+/g, " ")          // 여러 줄 바꿈을 공백 하나로 (Collapse multiple newlines to a single space)
            .replace(/\s\s+/g, " ")      // 연속된 공백을 하나로 (Collapse multiple consecutive spaces to a single space)
            .trim();                       // 앞뒤 공백 제거 (Trim leading/trailing whitespace)

          if (plainText) {
            // 첫 번째 문장 추출 (Extract the first sentence)
            // 마침표(.), 물음표(?), 느낌표(!) 뒤에 공백이 오거나 문자열의 끝을 기준으로 문장을 나눔
            const sentenceMatch = plainText.match(/^[^.!?]+[.!?](\s|$)/);

            if (sentenceMatch) {
              description = sentenceMatch[0].trim(); // 추출된 첫 문장 (Extracted first sentence)
            } else {
              // 문장 종결 부호가 없는 경우, 처음 160자로 제한 (Fallback to 160 chars if no sentence terminator)
              description = plainText.substring(0, 160) + (plainText.length > 160 ? "…" : "");
            }
          } else {
            description = ""; // 본문 파싱 후 내용이 없으면 공란 (Blank if no content after parsing body)
          }
        } catch (e) {
          console.warn(`[RSS Feed] Post ID "${post.id}" (title: "${post.data.title}"): Failed to generate description from body. Error: ${e.message}.`);
          description = ""; // 오류 발생 시 공란 처리 (Blank on error)
        }
      } else if (!description) {
        description = ""; // 공란으로 설정 (Set to blank)
      }

      return {
        title: post.data.title ?? "제목 없음", // Untitled
        description, // 위에서 처리된 description 사용 (Use the processed description from above)
        // 중요: link는 사이트의 실제 포스트 URL 구조와 일치해야 합니다.
        // IMPORTANT: The link must match your site's actual post URL structure.
        // 여기서는 post.slug (파일명 기반 슬러그)를 사용합니다.
        // Here, we use post.slug (filename-based slug).
        link: `/posts/${post.slug}/`, // 예: /posts/my-first-post/ (e.g., /posts/my-first-post/)
        pubDate: dateObject, // Date 객체를 사용 (Use the Date object)
      };
    })
  );

  // null인 아이템(오류 등으로 건너뛴 포스트)을 필터링합니다.
  // Filter out null items (posts skipped due to errors, etc.).
  const validItems = items.filter(item => item !== null);

  return rss({
    title: "낱말로 쌓은 성", // Your blog title
    description: "오롯이 내 생각과 의견", // Your blog description
    site: context.site || "https://graywoods.me", // Astro.site 또는 기본값 (Astro.site or fallback)
    items: validItems, // 유효한 아이템만 포함 (Include only valid items)
    customData: `<language>ko-kr</language>`,
  });
}
